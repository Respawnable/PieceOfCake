#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTCS2,          sensorNone)
#pragma config(Sensor, S3,     IRseeker,       sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servoFlip,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "rdpartyrobotcdr-3.3.1\drivers\hitechnic-irseeker-v2.h"

#define DRIVE_SPEED 30
#define ENCODER_TICKS_INCH 100

string Left = "L";
string Right = "R";

int DistanceToIR = 0; //Distance from beacon
int _dirAC = 0; //Sensor number
int acS1, acS2, acS3, acS4, acS5 = 0; //Stores IR sensor values
int maxSig = 0; // The max signal strength from the seeker.
int flipper_start_pos = 0; //Flat
int turnTime = 75; // Time (ms) to complete 90 degree turn.
// This variable is set by the MoveToIR function (It knows where the beacon is located).
string beaconDirection = "L"; // Which side of the robot is the beacon on
int irGoal = 3; // Which sensor is pointing to the left or right of the robot?
int servoMoveRange = 120; // Servo location to dump block (assumes 0 = rest position).

float InchesToTape = 18;
float InchesToRamp = 25;

void initializeRobot()
{
	servoChangeRate[servoFlip] = 20; // Servo Change Rate, positions per update (20ms).
	servo[servoFlip] = flipper_start_pos;
}

int convert(float inches)
{
	return (int)(inches * ENCODER_TICKS_INCH);
}

void driveMotors(int lspeed, int rspeed)
{
	motor[motorL] = lspeed;
	motor[motorR] = rspeed;
}

void MoveForward ()
{
	driveMotors (DRIVE_SPEED, DRIVE_SPEED);
}

void StopMotors()
{
	driveMotors(0,0);
	wait1Msec(20);
}

void GoInches(float inches, int speed)
{
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait1Msec(200);
	motor[motorL] = speed;
	motor[motorR] = speed;
	while ((abs(nMotorEncoder[motorR]) + abs(nMotorEncoder[motorL])) / 2 < (convert(inches)))
	{
	}

	StopMotors();
}

// Run servo to dump block and return arm to rest.
void DumpBlock()
{
	servo[servoFlip] = servoMoveRange; //Flip the ball out.
	wait1Msec(200);
	servo[servoFlip] = ServoValue[servoFlip] - servoMoveRange; //Move back to the starting position.
}

// Move back to start after a trip to the IR beacon.
void BackToStart()
{
	nxtDisplayTextLine(4, "Distance: %d", DistanceToIR);
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait1Msec(200);
	nMotorEncoderTarget[motorL] = -DistanceToIR;
	nMotorEncoderTarget[motorR] = -DistanceToIR;
	wait1Msec(200);
	motor[motorL] = -DRIVE_SPEED;
	motor[motorR] = -DRIVE_SPEED;
	while (nMotorEncoder[motorL] <= DistanceToIR || nMotorEncoder[motorR] != DistanceToIR)
	{
		nxtDisplayTextLine(1, "Enc: %d", nMotorEncoder[motorL]);
	}
}

void MovetoIR()
{
	int FindState = 1;
	bool FoundIt = false;
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait1Msec(200);

	// Start moving.
	driveMotors(DRIVE_SPEED, DRIVE_SPEED);
	while(!FoundIt)
	{
		switch (FindState)
		{
		case 1:
			// Look for target
			// Get the direction.
			_dirAC = HTIRS2readACDir(IRseeker);

			// Set the direction for the turn90 function.
			beaconDirection = _dirAC < 0 ? "L" : "R";

			// Make 0 straight ahead, all positive, no left or right worry.
			_dirAC = abs(_dirAC - 5);

			// Get the strength.
			//nxtDisplayTextLine(1, "IR: %d", _dirAC);

			HTIRS2readAllACStrength(IRseeker, acS1, acS2, acS3, acS4, acS5);
		maxSig = (acS1 > acS2) ? acS1 : acS2;
		maxSig = (maxSig > acS3) ? maxSig : acS3;
		maxSig = (maxSig > acS4) ? maxSig : acS4;
		maxSig = (maxSig > acS5) ? maxSig : acS5;
			nxtDisplayTextLine(2, "maxSig: %d", maxSig);

			wait10Msec(2);
			if (_dirAC >= irGoal)
			{
				StopMotors();
				DistanceToIR = nMotorEncoder[motorR];
				FindState++;
			}
			break;
		case 2:
			// Look for strongest signal.
			FindState++;
			break;
		case 3:
			// Backup a little.
			FindState++;
			FoundIt = true;
			break;
		}
	}
}

// Turn 90 degrees.
void Turn90(string direction)
{
	// Adjust the requested direction to reflect the actual location of the beacon.
	direction = beaconDirection == direction ? "L" : "R";
	motor[motorL] = direction == "L" ? -DRIVE_SPEED : DRIVE_SPEED;
	motor[motorR] = -motor[motorL];
	wait10Msec(turnTime);
	StopMotors();
}

task main()
{
	initializeRobot();
	//waitForStart();
	//MoveForward();
	//MovetoIR();
	DumpBlock();
	//BackToStart();
	//Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);
	//Turn90(Right);
	//GoInches(InchesToRamp, DRIVE_SPEED);
	StopMotors();
	wait10Msec(1);
	//// Wait for FCS to stop us.
	while (true)
	{
		//note to self play songs
		PlaySoundFile();
	}
}
