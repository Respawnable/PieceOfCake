#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S2,     HTCS2,          sensorI2CCustom)
#pragma config(Sensor, S3,     IRseeker,       sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorR,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorL,        tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servoFlip,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "rdpartyrobotcdr-3.3.1\drivers\hitechnic-irseeker-v2.h"

#define ENCODER_TICKS_INCH 200
#define DRIVE_SPEED 40

string Left = "L";
string Right = "R";
int DistanceToIR = 0;
int _dirAC = 0;
int acS1, acS2, acS3, acS4, acS5 = 0;
int maxSig  = 0; 					// The max signal strength from the seeker.

// These are the tuning variables. Set these based on results of test runs.
int flipper_start_pos = 26;				// Flat.
int turnTime = 145; // Time (ms) to complete 90 degree turn.
int beaconDirection = 1;// Which side of the robot is the beacon on (1=left, 2=right).
int irGoal = 3;						// Where is the beacon.
float InchesToTape = 18;	// Distance to tape from last 90 degree turn.
float InchesToRamp = 25;	// Distance along tape to the ramp.

void initializeRobot()
{
	servoChangeRate[servoFlip] = 20;          // Slow the Servo Change Rate down to only 4 positions per update.
	servo[servoFlip] = flipper_start_pos;
}

int convert(float inches)
{
	return (int)(inches * ENCODER_TICKS_INCH);
}


void driveMotors(int lspeed, int rspeed)
{
	motor[motorL] = lspeed;
	motor[motorR] = rspeed;
}

void MoveForward ()
{
	driveMotors (DRIVE_SPEED, DRIVE_SPEED);
}

void StopMotors()
{
	driveMotors(0,0);
	wait1Msec(20);
}

void GoInches(float inches, int speed)
{
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait1Msec(200);
	motor[motorL] = speed;
	motor[motorR] = speed;
	while ((abs(nMotorEncoder[motorR]) + abs(nMotorEncoder[motorL])) / 2 < (convert(inches)))
	{
	}

	StopMotors();
}

// Run servo to dump block and return arm to rest.
void DumpBlock()
{
}

// Move back to start after a trip to the IR beacon.
void BackToStart()
{
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait1Msec(200);
	nMotorEncoderTarget[motorL] = -DistanceToIR;
	nMotorEncoderTarget[motorR] = -DistanceToIR;
	motor[motorL] = -DRIVE_SPEED;
	motor[motorR] = -DRIVE_SPEED;
	while (nMotorRunState[motorL] != runStateIdle || nMotorRunState[motorR] != runStateIdle)
	{
	}
}

// Move foward until the beacon is found.
void MovetoIR()
{
	int FindState = 1;
	bool FoundIt = false;
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait1Msec(200);

	// Start moving.
	driveMotors(DRIVE_SPEED, DRIVE_SPEED);
	while(!FoundIt)
	{
		switch (FindState)
		{
		case 1:
			// Look for target
			// Get the direction.
			_dirAC = HTIRS2readACDir(IRseeker);
			// Make 0 straight ahead, all positive, no left or right worry.
			_dirAC = abs(_dirAC - 5);
			// Get the strength.
			nxtDisplayTextLine(1, "IR: %d", _dirAC);

			HTIRS2readAllACStrength(IRseeker, acS1, acS2, acS3, acS4, acS5);
		maxSig = (acS1 > acS2) ? acS1 : acS2;
		maxSig = (maxSig > acS3) ? maxSig : acS3;
		maxSig = (maxSig > acS4) ? maxSig : acS4;
		maxSig = (maxSig > acS5) ? maxSig : acS5;
			nxtDisplayTextLine(2, "maxSig: %d", maxSig);

			wait10Msec(2);
			if (_dirAC >= irGoal)
			{
				StopMotors();
				DistanceToIR = nMotorEncoder[motorR];
				FindState++;
			}
			break;
		case 2:
			// Look for strongest signal.
			FindState++;
			break;
		case 3:
			// Backup a little.
			FindState++;
			FoundIt = true;
			break;
		}
	}
}

//Turn 90 degrees.
void Turn90(string direction)
{
	direction = beaconDirection == 1 ? "L" : "R";
	motor[motorL] = direction == "R" ? DRIVE_SPEED : -DRIVE_SPEED;
	motor[motorR] = -motor[motorL];
	wait10Msec(turnTime);
	StopMotors();
}

task main()
{
	initializeRobot();
	//waitForStart();

	MovetoIR();
	DumpBlock();
	BackToStart();
	Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Right);
	GoInches(InchesToRamp, DRIVE_SPEED);
	StopMotors();

	// Wait for FCS to stop us.
	while (true)
	{
	}
}
