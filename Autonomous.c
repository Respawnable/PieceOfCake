#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     HTCS2,          sensorNone)
#pragma config(Sensor, S2,     IRseeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,           ,             tmotorNXT, PIDControl)
#pragma config(Motor,  mtr_S1_C1_1,     motorL,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorR,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "rdpartyrobotcdr-3.3.1\drivers\hitechnic-irseeker-v2.h"
#include "rdpartyrobotcdr-3.3.1\drivers\hitechnic-colour-v2.h"

// Set this based on the alliance for each competition.
#define TURN_DIRECTION "L"
#define TURN_TIME 145 // Time (ms/10) to complete the turn.
// The value we look for from the white tape.
#define WHITE_LINE_VALUE 0
// The radius in inches of a wheel.
#define WHEEL_RADIUS 2
// The robot track in inches.
#define TRACK 9
// Encode ticks for 1 revolution.
#define TICKS_PER_REV 1440
// FIGURE THIS OUT.
#define ENCODER_TICKS_INCH 200

// The GetColor task will update these.
int _color = 0;
int red = 0;
int green = 0;
int blue = 0;

// Motor power levels.
int powerLevel = 25;
float centerOfWheelToCenterOfRobotMM = 45.0;
float wheelDiameterMM = 56.0;
//
// Get the Wheel's circumference
float wheelCircumference = wheelDiameterMM * PI;  // Formula.  NOT changeable.
//
// If no gears are used, then the gear ratio should be "(float) 1 / 1"
float gearRatio = 1.0;
// gearRatio = (float) 24 / 40;   (Example of two gears)
// Format for the gear ratio is:
//   If 2 gears:  (Gear that connects to the wheel) / (gear that connects to the motor)
//   If 3 gears:  a / b / c
//      where a = the gear that connects to the wheel
//            c = the gear that connects to the motor
//            b = the gear in the middle
// In general, start with the gear at the wheel and divide it by each gear
// in sequential order as you get closer to the gear connected to the motor

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	disableDiagnosticsDisplay();
	eraseDisplay();
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	return;
}

int convert(float inches)
{
	return (int)(inches * ENCODER_TICKS_INCH);
}

int convertDegree(float degree)
{
	return (int)(degreesToRadians(degree));
}

void GoInches(float inches, int speed)
{
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait1Msec(200);
	motor[motorL] = speed;
	motor[motorR] = speed;
	while (abs(nMotorEncoder[motorR]) < (convert(inches)) || abs(nMotorEncoder[motorL]) < (convert(inches)))
	{
		nxtDisplayTextLine(7, "Motor encoder: %d", nMotorEncoder[motorR]);
	}

	motor[motorL] = 0;
	motor[motorR] = 0;
	wait1Msec(200);
}

void goDegrees(float degree, int speed)
{
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorL] = 0;
	wait1Msec(300);
	motor[motorL] = -speed;
	motor[motorR] = speed;
	while ((abs(nMotorEncoder[motorR]) < (convertDegree(degree))) || abs(nMotorEncoder[motorL]) < (convertDegree(degree)))
	{
	}

	motor[motorL] = 0;
	motor[motorR] = 0;
	wait1Msec(300);
}

// Update the global color variables for use where needed.
task getColor()
{
	// Read the currently detected colour from the sensor
	_color = HTCS2readColor(HTCS2);
	// If colour == -1, it implies an error has occurred
	if (_color < 0) {
		nxtDisplayTextLine(7, "HTCS2readColor sensor error!");
		wait1Msec(2000);
		StopAllTasks();
	}

	if (!HTCS2readRGB(HTCS2, red, green, blue)) {
		nxtDisplayTextLine(7, "HTCS2readRGB sensor error!");
		wait1Msec(2000);
		StopAllTasks();
	}

	nxtDisplayCenteredTextLine(0, "Color: %d", _color);
	nxtDisplayCenteredBigTextLine(1, "R  G  B");

	nxtEraseRect(0,10, 99, 41);
	nxtFillRect( 0, 10, 30, 10 + (red+1)/8);
	nxtFillRect(35, 10, 65, 10 + (green+1)/8);
	nxtFillRect(70, 10, 99, 10 + (blue+1)/8);
	EndTimeSlice();
}

void driveMotors(int lspeed, int rspeed)
{
	motor[motorL] = lspeed;
	motor[motorR] = rspeed;
}

void MoveForward ()
{
  motor[motorL] = powerLevel;
  motor[motorR] = powerLevel;
}

void MoveForwardTime(int milliSeconds)
{
	MoveForward();
	wait1Msec(milliSeconds);
}

void StopMotors()
{
	driveMotors(0,0);
}

// Calculate turn durations
int GetTurnDuration(int degrees)
{
	return (TRACK / WHEEL_RADIUS) * degrees;
}

// Turn 90 degrees.
void Turn90()
{
	int turnSpeed = 75;
	motor[motorL] = (TURN_DIRECTION == "R") ? turnSpeed : -turnSpeed;
	motor[motorR] = -motor[motorL];
	wait10Msec(TURN_TIME);
	motor[motorL] = 0;
	motor[motorR] = 0;

	//zero encoders
	//motors on
	//while(left encoder - right encoder < 1000) { }  //the right encoder will count backwards during a right turn
	//motors off
}

task main()
{
	initializeRobot();
	StartTask(getColor);

	//waitForStart(); // Wait for the beginning of autonomous phase.

	while (true)
	{
		// Step 1: Move forward until white line.
		//GoInches(12.0, 30);
		//MoveForwardTime(3000);
		while (_color != WHITE_LINE_VALUE)
		{
			MoveForward();
			EndTimeSlice();
		}

		StopMotors();

		// Step 2: Turn 90 degrees.
		Turn90();

		// Step 3: Move forward for x inches.

		// Step 4: Stop.
		StopMotors();

		//StopAllTasks();
		//break;
	}
}
