#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTCS2,          sensorNone)
#pragma config(Sensor, S3,     IRseeker,       sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servoFlip,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "rdpartyrobotcdr-3.3.1\drivers\hitechnic-irseeker-v2.h"

// Pause for the other alliance?
#define BEFORE_START_10MS 0
#define DRIVE_SPEED 60
#define ENCODER_TICKS_INCH 100
#define ENCODER_TICKS_90_TURN 2880

string Left = "L";
string Right = "R";

int DistanceToIR = 0; //Distance from beacon
int _dirAC = 0; //Sensor number
int acS1, acS2, acS3, acS4, acS5 = 0; //Stores IR sensor values
int maxSig = 0; // The max signal strength from the seeker.
int flipper_start_pos = 0; //Flat
int turnTime = 60; // Time (ms) to complete 90 degree turn.
// This variable is set by the MoveToIR function (It knows where the beacon is located).
string beaconDirection = "L"; // Which side of the robot is the beacon on
int irGoal = 3; // Which sensor is pointing to the left or right of the robot?
int servoMoveRange = 120; // Servo location to dump block (assumes 0 = rest position).

float InchesToTape = 18;
float InchesToRamp = 25;

// Function declarations.
void Turn90(string direction);
void ResetEncoders();
void StopMotors();

void initializeRobot()
{
	servoChangeRate[servoFlip] = 20; // Servo Change Rate, positions per update (20ms).
	servo[servoFlip] = flipper_start_pos;
	ResetEncoders();
	disableDiagnosticsDisplay();
}

int convert(float inches)
{
	return (int)(inches * ENCODER_TICKS_INCH);
}

void driveMotors(int lspeed, int rspeed)
{
	motor[motorL] = lspeed;
	motor[motorR] = rspeed;
}

void MoveForward ()
{
	driveMotors (DRIVE_SPEED, DRIVE_SPEED);
}

void StopMotors()
{
	driveMotors(0,0);
	wait10Msec(20);
}

void ResetEncoders()
{
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait10Msec(30);
}

void GoInches(float inches, int speed)
{
	ResetEncoders();
	wait1Msec(200);
	motor[motorL] = speed;
	motor[motorR] = speed;
	while ((abs(nMotorEncoder[motorR]) + abs(nMotorEncoder[motorL])) / 2 < (convert(inches)))
	{
	}

	StopMotors();
}

// Run servo to dump block and return arm to rest.
void DumpBlock()
{
	servo[servoFlip] = servoMoveRange; //Flip the block out.
	wait1Msec(200);
	servo[servoFlip] = ServoValue[servoFlip] - servoMoveRange; //Move back to the starting position.
}

// Move back to start after a trip to the IR beacon.
void BackToStart()
{
	if (DistanceToIR == 0)
	{
		return;
	}

	//nxtDisplayTextLine(4, "Distance: %d", DistanceToIR);
	ResetEncoders();
	nMotorEncoderTarget[motorL] = DistanceToIR;
	nMotorEncoderTarget[motorR] = DistanceToIR;
	wait10Msec(30);
	motor[motorL] = -DRIVE_SPEED;
	motor[motorR] = -DRIVE_SPEED;
	while (nMotorRunState[motorL] != runStateIdle || nMotorRunState[motorR] != runStateIdle)
	{
		nxtDisplayTextLine(3, "Enc: %d", nMotorEncoder[motorL]);
		nxtDisplayTextLine(4, "RunState: %d", nMotorRunState[motorL]);
	}
}

void MovetoIR()
{
	int FindState = 1;
	bool FoundIt = false;
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait1Msec(200);

	// Use a timer to prevent runaway!
	ClearTimer(T1);
	// Start moving.
	driveMotors(DRIVE_SPEED, DRIVE_SPEED);
	// Adjust timer if needed, just enough to get to the IR.
	// If we don't find it, timeout and move on.
	while(!FoundIt && time1[T1] < 5000)
	{
		switch (FindState)
		{
		case 1:
			// Look for target
			// Get the direction.
			_dirAC = HTIRS2readACDir(IRseeker);
			// Make 0 straight ahead, all positive, no left or right worry.
			_dirAC = _dirAC - 5;
			// Set the direction for the turn90 function.
		beaconDirection = _dirAC < 0 ? "L" : "R";
			// We need it without sign so left and right are ignored.
			_dirAC = abs(_dirAC);
			nxtDisplayTextLine(1, "Direction: %d", _dirAC);
			// Get the strength.
			HTIRS2readAllACStrength(IRseeker, acS1, acS2, acS3, acS4, acS5);
		maxSig = (acS1 > acS2) ? acS1 : acS2;
		maxSig = (maxSig > acS3) ? maxSig : acS3;
		maxSig = (maxSig > acS4) ? maxSig : acS4;
		maxSig = (maxSig > acS5) ? maxSig : acS5;
			nxtDisplayTextLine(2, "maxSig: %d", maxSig);

			wait10Msec(2);
			if (_dirAC >= irGoal)
			{
				StopMotors();
				DistanceToIR = nMotorEncoder[motorL];
				FindState++;
			}
			break;
		case 2:
			// Look for strongest signal.
			FindState++;
			break;
		case 3:
			// Backup a little.
			FindState++;
			FoundIt = true;
			break;
		}
	}
}

// Test functions here.
void LookForBeacon()
{
	while (true)
	{
		_dirAC = HTIRS2readACDir(IRseeker);
		// Make 0 straight ahead, all positive, no left or right worry.
		_dirAC = _dirAC - 5;
		// Set the direction for the turn90 function.
	beaconDirection = _dirAC < 0 ? "L" : "R";
		// We need it without sign so left and right are ignored.
		_dirAC = abs(_dirAC);
		nxtDisplayTextLine(1, "Direction: %d", _dirAC);
		// Get the strength.
		HTIRS2readAllACStrength(IRseeker, acS1, acS2, acS3, acS4, acS5);
	maxSig = (acS1 > acS2) ? acS1 : acS2;
	maxSig = (maxSig > acS3) ? maxSig : acS3;
	maxSig = (maxSig > acS4) ? maxSig : acS4;
	maxSig = (maxSig > acS5) ? maxSig : acS5;
		nxtDisplayTextLine(2, "maxSig: %d", maxSig);

		wait10Msec(2);
	}
}

void DriveSquareTest()
{
	Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);

	Turn90(Right);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Right);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Right);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Right);
	GoInches(InchesToTape, DRIVE_SPEED);
}

// This function uses encoders to turn.
void PointTurn(string direction)
{
	// Adjust the requested direction to reflect the actual location of the beacon.
	direction = beaconDirection == direction ? "L" : "R";
	ResetEncoders();
	nMotorEncoderTarget[motorL] = direction == "L" ? -ENCODER_TICKS_90_TURN : ENCODER_TICKS_90_TURN;
	nMotorEncoderTarget[motorR] = direction == "L" ? ENCODER_TICKS_90_TURN : -ENCODER_TICKS_90_TURN;
	wait1Msec(200);
	motor[motorL] = DRIVE_SPEED;
	motor[motorR] = -DRIVE_SPEED;
	while (nMotorRunState[motorL] != runStateIdle || nMotorRunState[motorR] != runStateIdle)
	{
	}
}

// Turn 90 degrees.
void Turn90(string direction)
{
	// Adjust the requested direction to reflect the actual location of the beacon.
	direction = beaconDirection == direction ? "L" : "R";
	motor[motorL] = direction == "L" ? -DRIVE_SPEED : DRIVE_SPEED;
	motor[motorR] = -motor[motorL];
	wait10Msec(turnTime);
	StopMotors();
}

task main()
{
	initializeRobot();
	//waitForStart();

	wait10Msec(BEFORE_START_10MS);
	MovetoIR();
	DumpBlock();
	BackToStart();
	Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Right);
	GoInches(InchesToRamp, DRIVE_SPEED);

	// Test Function Here
	//PointTurn(Left);
	//DriveSquaresTest();
	//LookForBeacon();

	StopMotors();
	wait1Msec(200);

	// Wait for FCS to stop us.
	while (true)
	{
		//note to self play songs
		PlaySoundFile("woops.rso");
	}
}
